// Copyright (c) YugaByte, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
// except in compliance with the License.  You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied.  See the License for the specific language governing permissions
// and limitations under the License.
//

// This file is partially autogenerated.
//
// Initial Prompt:
// I want to create a new app that runs the following command:
//
// SELECT event_time
// FROM
//     events
// WHERE
//     event_time < now();
//
// This happens on the read thread. The write thread is immaterial. It can simply do some random
// updates that move the oldest timestamp to the newest timestamp. Use the timestamp column for
// the events table and do not use the timestamptz column. This will prevent the condition
// from being pushed down as an index condition. There must be an index on the event_time
// timestamp column so that this is an index condition. Make sure only a few rows are selected
// by the query. This means that only a fraction, such as 1/10 of the rows, have a timestamp
// less than now(). In fact, add an index scan hint to force an index scan. One reader and one
// writer are sufficient, but feel free to add more.
//
// Let's have another mode (through the use of a command-line flag) that switches the schema
// from using a timestamp column to a timestamptz column. We cannot allow truncate. Always
// drop and recreate the schema in the create table function. This will push down the index
// condition, and it should lead to better throughput.
package com.yugabyte.sample.apps;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Arrays;
import java.util.List;

import org.apache.log4j.Logger;

import com.yugabyte.sample.common.CmdLineOpts;

public class SqlExpiredEvents extends SQLAppBase {
    private static final Logger LOG = Logger.getLogger(SqlExpiredEvents.class);

    private static final String DEFAULT_TABLE_NAME = "events";
    private volatile PreparedStatement preparedSelect;

    static {
        appConfig.numReaderThreads = 1;
        appConfig.numWriterThreads = 0;
        appConfig.numKeysToRead = -1;
        appConfig.numKeysToWrite = -1;
        appConfig.numUniqueKeysToWrite = 100000;
        appConfig.readOnly = true;
    }

    @Override
    public void initialize(CmdLineOpts configuration) {
        super.initialize(configuration);
        if (configuration.getCommandLine().hasOption("use_timestamptz")) {
            appConfig.useTimestamptz = true;
        }
    }

    @Override
    public String getTableName() {
        return appConfig.tableName != null ? appConfig.tableName : DEFAULT_TABLE_NAME;
    }

    @Override
    public void createTablesIfNeeded(TableOp tableOp) throws Exception {
        Connection connection = getPostgresConnection();
        String tableName = getTableName();
        String eventTimeColumnType = appConfig.useTimestamptz ? "TIMESTAMPTZ" : "TIMESTAMP";

        try (Statement stmt = connection.createStatement()) {
            LOG.info("Dropping table " + tableName);
            stmt.execute("DROP TABLE IF EXISTS " + tableName);

            String createTableSQL = String.format(
                "CREATE TABLE %s (id SERIAL PRIMARY KEY, event_time %s NOT NULL)",
                tableName, eventTimeColumnType
            );
            LOG.info("Creating table " + tableName + " with SQL: " + createTableSQL);
            stmt.execute(createTableSQL);

            String createIndexSQL = String.format("CREATE INDEX ON %s (event_time ASC)",
                                                   tableName);
            LOG.info("Creating index on " + tableName + " (event_time) with SQL: " +
                     createIndexSQL);
            stmt.execute(createIndexSQL);

            // Pre-populate with some data
            LOG.info("Populating " + tableName + " with initial data...");
            try (PreparedStatement insertStmt = connection.prepareStatement(
                    "INSERT INTO " + tableName + " (event_time) VALUES (?)"
            )) {
                for (int i = 0; i < appConfig.numUniqueKeysToWrite; i++) {
                    if (i < appConfig.numUniqueKeysToWrite / 10) {
                        // 1/10 of events are in the past
                        insertStmt.setTimestamp(1, new java.sql.Timestamp(
                            System.currentTimeMillis() - 3600 * 1000));
                    } else {
                        // 9/10 of events are in the future
                        insertStmt.setTimestamp(1, new java.sql.Timestamp(
                            System.currentTimeMillis() + 3600 * 1000));
                    }
                    insertStmt.addBatch();
                }
                insertStmt.executeBatch();
            }
            LOG.info("Initial data population complete.");

        } finally {
            connection.close();
        }
    }

    private PreparedStatement getPreparedSelect() throws Exception {
        if (preparedSelect == null) {
            String sql = String.format(
                "SELECT /*+ IndexScan(%s) */ event_time FROM %s WHERE event_time < now()",
                getTableName(), getTableName()
            );
            preparedSelect = getPostgresConnection().prepareStatement(sql);
        }
        return preparedSelect;
    }

    

    @Override
    public long doRead() {
        try {
            PreparedStatement statement = getPreparedSelect();
            try (ResultSet rs = statement.executeQuery()) {
                // Just execute the query without looping through results
            }
        } catch (Exception e) {
            LOG.error("Failed to read from " + getTableName(), e);
            preparedSelect = null;
            return 0;
        }
        return 1;
    }

    @Override
    public long doWrite(int threadIdx) {
        // No-op for this workload
        return 0;
    }

    @Override
    public List<String> getWorkloadDescription() {
        return Arrays.asList(
            "This app simulates reading expired events from a table.",
            "It uses a table with a timestamp or timestamptz column and an index on that column.",
            "The read operation selects events where the event time is in the past.",
            "The write operation updates the oldest event to be the newest.",
            "A command line flag '--use_timestamptz' can be used to switch the column type."
        );
    }

    @Override
    public List<String> getWorkloadOptionalArguments() {
        return Arrays.asList(
            "--num_reads " + appConfig.numKeysToRead,
            "--num_writes " + appConfig.numKeysToWrite,
            "--num_threads_read " + appConfig.numReaderThreads,
            "--num_threads_write " + appConfig.numWriterThreads,
            "--use_timestamptz"
        );
    }
}